-------------------------CH-12-Exposing Applications for External Access----------------------------------

Accessing Application from External Networks

OpenShift Container Platform offers many ways to expose your applications to external networks.
You can expose HTTP and HTTPS traffic, TCP applications, and also non-TCP traffic. Some of
these methods are service types, such as NodePort or load balancer, while others use their own
API resource, such as Ingress and Route.
OpenShift routes allow you to expose your applications to external networks. With routes, you can
access your application with a unique host name that is publicly accessible. Routes rely on a router
plug-in to redirect the traffic from the public IP to pods.

Note
For performance reasons, routers send requests directly to pods based on service
configuration.
The dotted line indicates this implementation. That is, the router accesses the pods
through the services network.

Describing Methods for Managing Ingress Traffic
The most common way to manage ingress traffic is with the Ingress Controller. OpenShift
implements the Ingress Controller with a shared router service that runs as a pod inside the cluster.
You can scale and replicate this pod like any other regular pod. This router service is based on the
open source software HAProxy.
Routes and ingress are the main resources for handling ingress traffic.

Route
Routes provide ingress traffic to services in the cluster. Routes were created before
Kubernetes ingress objects and provide more features. Routes provide advanced features that
may not be supported by Kubernetes ingress controllers through a standard interface, such as
TLS re-encryption, TLS passthrough, and split traffic for blue-green deployments.

Ingress
An ingress is a Kubernetes resource that provides some of the same features as routes (which
are an OpenShift resource). Ingresses accept external requests and proxy them based on the
route. You can only allow certain types of traffic: HTTP, HTTPS and server name identification
(SNI), and TLS with SNI. In OpenShift, routes are generated to meet the conditions specified
by the ingress object.
There are alternatives to ingress and routes, but they are for special use cases. The following
service types provide external access to services.

External load balancer
This resources instructs OpenShift to spin up a load balancer in a cloud environment. A load
balancer instructs OpenShift to interact with the cloud provider in which the cluster is running
to provision a load balancer.

Service external IP
This method instructs OpenShift to set NAT rules to redirect traffic from one of the cluster IPs
to the container.

NodePort
With this method, OpenShift exposes a service on a static port on the node IP address. You
must ensure that the external IP addresses are properly routed to the nodes.

Creating Routes
The easiest and preferred way to create a route (secure or insecure) is to use the oc expose
service service command, where service corresponds to a service. Use the --hostname
option to provide a custom host name for the route.

[user@demo ~]$ oc expose service api-frontend --hostname api.apps.acme.com

Important
The DNS server that hosts the wildcard domain is unaware of any route host names;
it only resolves any name to the configured IPs. Only the OpenShift router knows
about route host names, treating each one as an HTTP virtual host.
Invalid wildcard domain host names, that is, host names that do not correspond to
any route, are blocked by the OpenShift router and result in an HTTP 404 error.

Note
You can also let OpenShift automatically generate a host name for the route.
An optional path, for path-based routes.
• A target port on which the application listens. The target port usually corresponds to the port
that you define in the targetPort key of a service.
• An encryption strategy, depending on whether you need a secure or insecure route.
The following listing shows a minimal definition for a route:
kind: Route
apiVersion: route.openshift.io/v1
metadata:
name: a-simple-route
labels:
app: API
name: api-frontend
spec:
host: api.apps.acme.com
to:
kind: Service
name: api-frontend
port:
targetPort: 8443

The name of the route. This name must be unique.
A set of labels that you can use as selectors.
The host name of the route. This host name must be a subdomain of your wildcard domain
because OpenShift routes the wildcard domain to the routers.
The service to which to redirect the traffic. Although you use a service name, the route only
uses this information to determine the list of pods that receive the traffic.
The application port. Because routes bypass services, this must match the application port
and not the service port.

Securing Routes
Routes can be either secured or unsecured. Secure routes provide the ability to use several
types of TLS termination to serve certificates to the client. Unsecured routes are the simplest to
configure because they require no key or certificates, but secured routes encrypt traffic to and
from the pods.

A secured route specifies the TLS termination of the route. The available types of termination are
presented in the following list.
OpenShift Secure Routes

Edge
With edge termination, TLS termination occurs at the router, before the traffic is routed to
the pods. The router serves the TLS certificates, so you must configure them into the route;
otherwise, OpenShift assigns its own certificate to the router for TLS termination. Because
TLS is terminated at the router, connections from the router to the endpoints over the internal
network are not encrypted.

Passthrough
With passthrough termination, encrypted traffic is sent straight to the destination pod without
the router providing TLS termination. In this mode, the application is responsible for serving
certificates for the traffic. Passthrough is currently the only method that supports mutual
authentication between the application and a client that accesses it.

Re-encryption
Re-encryption is a variation on edge termination, whereby the router terminates TLS with a
certificate, and then re-encrypts its connection to the endpoint, which might have a different
certificate. Therefore, the full path of the connection is encrypted, even over the internal
network. The router uses health checks to determine the authenticity of the host.
